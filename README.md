[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15222003&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering: 
Answer:
is the sytematic applications of engineering principle to mantain and develop software systems.

What is software engineering, and how does it differ from traditional programming?    
Answer: 

Scope and Scale:
Traditional Programming: Focused on small-scale projects or individual programs.
Software Engineering: Deals with large-scale systems, requiring extensive planning and management.

Methodology:
Traditional Programming: May use ad-hoc methods with less formal structure.
Software Engineering: Uses structured methodologies and practices to ensure the software meets requirements and is maintainable.

Team Collaboration:
Traditional Programming: Often done by individuals or small teams.
Software Engineering: Typically involves large teams with specialized roles.

Lifecycle Management:
Traditional Programming: May not extensively cover the full lifecycle of software.
Software Engineering: Covers the entire software development lifecycle from requirements to maintenance.

Documentation and Quality Assurance:
Traditional Programming: Documentation and QA might be minimal.
Software Engineering: Emphasizes thorough documentation and rigorous quality assurance practices.
Software Development Life Cycle (SDLC):

Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.

Answer:
The software development cycle, also known as the Software Development Life Cycle (SDLC), is a structured process that outlines the stages involved in the development of a software product. Here are the typical phases of the SDLC:

1. Planning
Objective: Define the project goals, scope, and feasibility.
Activities:
Conduct feasibility studies (technical, operational, economic).
Define project scope and objectives.
Identify resources (time, money, personnel).
Create a high-level project plan.
2. Requirements Analysis
Objective: Gather and document detailed functional and non-functional requirements.
Activities:
Engage with stakeholders to understand their needs.
Document requirements in a clear and detailed manner.
Create use cases or user stories.
Validate requirements with stakeholders for completeness and accuracy.
3. Design
Objective: Define the architecture and detailed design of the system.
Activities:
Create system architecture diagrams.
Design database schemas and data structures.
Develop detailed design documents including UI/UX design.
Specify system components and interfaces.
4. Implementation (Coding)
Objective: Translate the design into actual code.
Activities:
Write the code according to design specifications.
Adhere to coding standards and guidelines.
Perform unit testing to ensure code correctness.
Use version control systems to manage code changes.
5. Testing
Objective: Verify that the software works as intended and is free of defects.
Activities:
Conduct various levels of testing (unit, integration, system, acceptance).
Perform automated and manual testing.
Identify and fix bugs.
Validate that the software meets the requirements.
6. Deployment
Objective: Release the software to the end-users.
Activities:
Prepare deployment environment (servers, databases, etc.).
Install and configure the software.
Conduct user training and support.
Roll out the software in stages (e.g., beta, full release).
7. Maintenance
Objective: Ensure the software remains functional and relevant.
Activities:
Monitor the software for issues and performance.
Provide ongoing support and troubleshooting.
Implement updates and enhancements.
Fix bugs and security vulnerabilities.

Agile vs. Waterfall Models:Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred? Requirements Engineering:

Answer:

Approach
Waterfall: Sequential and linear.
Agile: Iterative and incremental.

Flexibility:
Waterfall: Rigid and less adaptable to changes.
Agile: Highly flexible and responsive to change.

Documentation:
Waterfall: Extensive documentation.
Agile: Emphasizes working software over comprehensive documentation.

Customer Involvement:
Waterfall: Limited to the requirements phase.
Agile: Continuous involvement throughout the development process.

Risk Management:
Waterfall: Risks are identified early but changes are hard to manage.
Agile: Risks are managed through iterative reviews and continuous feedback.

Requirements Engineering
Agile Requirements Engineering:

User Stories and Backlogs: Requirements are gathered as user stories, which are prioritized and maintained in a product backlog.
Just-in-Time Requirements: Detailed requirements are developed just before implementation in each iteration, allowing for greater flexibility.
Collaboration: Continuous collaboration between developers, customers, and other stakeholders to refine requirements.
Waterfall Requirements Engineering:

Detailed Requirements Document: Comprehensive requirements are gathered and documented at the beginning of the project.
Fixed Requirements: Once approved, the requirements document serves as a baseline, with changes controlled through a formal process.
Phase-Specific: Requirements engineering is primarily a phase at the start of the project, with limited revisits unless formally changed.

Therefore choosing between Agile and Waterfall depends on the nature of the project, the clarity of requirements, stakeholder involvement, and the importance of flexibility versus predictability. Agile is suited for dynamic environments where adaptability and continuous improvement are key, while Waterfall is ideal for projects with well-defined requirements and a need for a structured, predictable process.

What is requirements engineering? Describe the process and its importance in the software development lifecycle.
Answer:

Requirements engineering is a systematic process in software and systems engineering that involves defining, documenting, and maintaining the requirements for a system.
Requirements engineering is an essential phase in the software development lifecycle (SDLC), ensuring that the final product meets the needs of stakeholders and operates effectively within its intended environment. The process consists of several key activities:

Requirements Elicitation:

Objective: Collect requirements from all stakeholders (users, customers, developers, etc.).
Importance: Ensures that all necessary functions and constraints of the system are identified early. It helps in understanding the user's needs and the context in which the system will operate.
Methods: Interviews, surveys, focus groups, observation, workshops, brainstorming sessions, and analyzing existing systems.

Requirements Analysis:
Objective: Refine and prioritize the gathered requirements, resolving any conflicts and ensuring their feasibility.
Importance: Helps in identifying potential issues, ambiguities, or conflicts in requirements, ensuring they are clear, complete, and realistic.
Techniques: Use case analysis, scenario analysis, prototyping, and modeling.

Requirements Specification:
Objective: Document the requirements in a clear, concise, and comprehensive manner.
Importance: Provides a detailed reference for developers and testers, ensuring everyone has a common understanding of what needs to be built.
Outputs: Requirements specification documents, user stories, and use cases.

Requirements Validation:
Objective: Ensure that the requirements accurately reflect stakeholder needs and expectations.
Importance: Reduces the risk of building a system that does not meet user needs by verifying the requirements with stakeholders before development begins.
Methods: Reviews, walkthroughs, inspections, and validation meetings with stakeholders.

Requirements Management:
Objective: Maintain and control the requirements throughout the project lifecycle.
Importance: Ensures that changes to requirements are tracked and managed, maintaining consistency and keeping stakeholders informed.
Activities: Tracking changes, maintaining requirements traceability, and ensuring effective communication of changes.

Importance of Requirements Engineering
1.Foundation for Design and Development, Clear requirements provide a solid foundation for system design, development, and testing.
2.Stakeholder Alignment, Ensures that all stakeholder needs and expectations are understood and agreed upon.
3.Risk Reduction, Identifies potential problems early in the lifecycle, reducing the likelihood of costly changes later.
4.Scope Management, Helps define and manage the project scope, preventing scope creep and ensuring the project stays on track.
5.Quality Assurance, Well-defined requirements lead to better design and testing, resulting in a higher quality product.

Software Design Principles are guidelines that help developers create systems that are robust, maintainable, and scalable. These principles ensure that software is well-structured and can be easily understood, modified, and extended. 

Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?
Answer:
Modularity refers to the design principle of breaking down a software system into separate, self-contained units or modules, each of which encapsulates a specific piece of functionality. These modules interact with each other through well-defined interfaces, but they are designed to be independently developed, tested, and maintained.

Improve Maintainability through:

1.Isolation of Changes, When a module needs to be changed or updated, the impact is limited to that module, reducing the risk of affecting other parts of the system.
2.Easier Debugging, Bugs can be isolated within a specific module, making it easier to identify and fix issues.
3.Simplified Testing, Individual modules can be tested independently, leading to more thorough and effective testing processes.

Improve Scalability through:

1.Independent Development, Multiple modules can be developed simultaneously by different teams, speeding up the development process.
2.Reusable Modules, Well-designed modules can be reused across different projects or parts of the same project, saving development time and effort.
3.Incremental Scaling, The system can be scaled by adding new modules without needing to redesign the entire system.

Testing in Software Engineering: Software testing  is a critical phase in the software development lifecycle (SDLC) aimed at evaluating a software application to ensure it meets specified requirements and is free of defects. 

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing).Why is testing crucial in software development?

Software testing involves several levels, each designed to identify different types of issues at various stages of the software development lifecycle. These levels ensure that the software is built correctly and meets the intended requirements.

Levels:
Unit Testing:
Definition: The process of testing individual components or units of code (e.g., functions, methods, classes) in isolation to ensure they work as intended.
Objective: Validate that each unit of the software performs as designed.
Performed By: Typically done by developers.
Tools: JUnit, NUnit, TestNG, pytest.
Importance: Detects issues early in the development process, making them easier and cheaper to fix. Ensures that each part of the code is correct before integrating it with other parts.

Integration Testing:
Definition: The process of testing the interaction between integrated units or modules to ensure they work together as expected.
Objective: Identify issues in the interfaces and interaction between integrated units.
Performed By: Developers or testers.
Approaches:
Big Bang Integration: Testing all modules together at once.
Incremental Integration: Testing modules step by step, either top-down or bottom-up.
Tools: JUnit, TestNG, Selenium, Apache JMeter.
Importance: Ensures that combined units work together properly and identifies issues related to module interactions early.

System Testing:
Definition: The process of testing the complete integrated system as a whole to ensure it meets the specified requirements.
Objective: Validate the end-to-end functionality of the system and ensure it meets the business and functional requirements.
Performed By: Testers.
Types: Functional testing, performance testing, security testing, usability testing.
Tools: Selenium, LoadRunner, QTP/UFT.
Importance: Verifies that the complete system works as intended in a fully integrated environment, catching issues that may not have been detected in earlier testing phases.

Acceptance Testing:
Definition: The process of testing the system from the user’s perspective to ensure it meets their requirements and is ready for deployment.
Objective: Validate that the software meets the business requirements and is acceptable for delivery.
Performed By: End-users, customers, or testers.
Types:
Alpha Testing: Conducted by internal staff before releasing to external users.
Beta Testing: Conducted by a limited number of end-users in a real-world environment.
Tools: TestRail, JIRA, HP Quality Center.
Importance: Ensures that the software meets user needs and requirements, providing a final verification before release.

Testing is crucial in software development due to the following reasons:

1.Quality Assurance
Ensures that the software meets quality standards and works reliably under various conditions.
Detects defects and issues early, preventing them from reaching end-users.

2.Cost Efficiency:
Identifying and fixing defects early in the development process is cheaper than fixing them after release.
Reduces the cost of post-release maintenance and support.

3.Risk Mitigation:
Identifies potential risks and vulnerabilities, such as security issues, before they can be exploited.
Ensures that the software is robust and can handle unexpected conditions or inputs.

4.Customer Satisfaction:
Ensures that the software meets user requirements and expectations.
Provides a positive user experience, leading to higher user satisfaction and loyalty.

5.Compliance and Standards:
Ensures that the software complies with industry standards, regulations, and legal requirements.
Helps avoid legal issues and penalties associated with non-compliance.

6.Improved Performance:
Identifies and resolves performance issues, ensuring that the software performs well under various conditions.
Enhances the scalability and efficiency of the software.

7.Enhanced Reputation:
Delivering high-quality, reliable software enhances the reputation of the development team and organization.
Builds trust with users and stakeholders, leading to more business opportunities.

Version Control Systems: are tools used to manage changes to source code over time. They enable multiple developers to collaborate on a project, track changes, revert to previous versions, and maintain a history of modifications. VCS is essential for maintaining the integrity and efficiency of the development process, especially in collaborative environments.

What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.

Answer:
Version Control Systems (VCS) are tools used to manage and track changes to source code and other project files over time. They enable multiple developers to collaborate on a project by keeping a detailed history of every modification made, allowing for efficient management of changes and ensuring that the project remains organized and maintainable.

Importance of Version Control Systems in Software Development

1.Collaboration:
VCS allows multiple developers to work on the same project simultaneously without overwriting each other's work. Changes from different contributors can be merged systematically, enabling teamwork on a global scale.

2.History and Traceability:
Every change made to the project is recorded along with metadata (e.g., who made the change, why it was made, and when it was made). This history is crucial for tracking the evolution of the project and understanding the reasons behind specific changes.

3.Backup and Recovery:
VCS serves as a backup system, allowing developers to revert to previous versions of the code if something goes wrong. This helps in quickly recovering from mistakes or implementing experimental features without risk.

4.Branching and Merging:
Developers can create branches to work on new features or bug fixes in isolation from the main codebase. Once the work is complete and stable, it can be merged back into the main branch. This ensures that the main codebase remains stable while allowing for parallel development.

5.Code Quality:
VCS often integrates with other tools for continuous integration, automated testing, and code reviews, which helps maintain high code quality and facilitates continuous delivery practices.

6.Accountability:
By recording who made each change, VCS ensures accountability and helps in auditing code changes. This can be useful for understanding contributions and for legal or compliance purposes.

Examples of Popular Version Control Systems and Their Features

1.Git
Type: Distributed Version Control System (DVCS).
Features:
Distributed Architecture: Every developer has a full copy of the repository, including its history.
Branching and Merging: Lightweight branching and efficient merging capabilities.
Performance: Fast and efficient for handling large projects.
Tools: Widely supported with tools like GitHub, GitLab, Bitbucket, and various GUI clients.
Community: Large community and extensive documentation.
Usage: Ideal for open-source projects, large teams, and projects requiring robust branching and merging.

2.Subversion (SVN):
Type: Centralized Version Control System (CVCS).

Features:
Central Repository: A single central repository from which developers check out and commit changes.
Atomic Commits: Ensures that either all changes in a commit are applied, or none are, preventing partial updates.
Directory Versioning: Supports versioning of entire directories and metadata.
Access Control: Fine-grained access control and permissions.
Usage: Commonly used in enterprise environments where a centralized control system is preferred.

3.Mercurial:
Type: Distributed Version Control System (DVCS).

Features:
Simplicity: User-friendly with a straightforward command set.
Performance: Efficient handling of large repositories.
Branching and Merging: Strong support for branching and merging similar to Git.
Tools: Available through platforms like Bitbucket.
Usage: Suitable for projects where ease of use and performance are important.

4.Perforce (Helix Core):
Type: Centralized Version Control System (CVCS).

Features:
Scalability: Handles large-scale projects with thousands of users and files.
File Locking: Supports exclusive check-outs to prevent conflicts in binary files.
Performance: Optimized for large repositories and fast performance.
Integration: Integrates with a wide range of development tools and environments.
Usage: Often used in industries like gaming and large-scale enterprises with complex needs.

Software Project Management this involves planning, organizing, and managing resources to achieve specific software development goals. It includes a variety of activities such as project planning, resource allocation, risk management, quality assurance, and communication.

Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?

Answer:
A software project manager is responsible for planning, executing, and overseeing software development projects to ensure they are completed on time, within scope, and on budget. They act as the bridge between the development team and other stakeholders, ensuring clear communication and alignment of project goals.

Key Responsibilities of a Software Project Manager

1.Project Planning:
Defining Scope: Establishing the project scope, objectives, and deliverables in collaboration with stakeholders.
Creating Schedules: Developing a detailed project schedule with milestones, deadlines, and resource allocation.
Budgeting: Estimating costs and creating a budget, ensuring the project stays within financial constraints.

2.Resource Management:
Team Coordination: Assigning tasks and responsibilities to team members based on their skills and availability.
Resource Allocation: Ensuring that all necessary resources (human, technical, financial) are available and efficiently utilized.

3.Risk Management:
Identifying Risks: Recognizing potential project risks and developing mitigation strategies.
Monitoring Risks: Continuously monitoring risks and updating risk management plans as needed.

4.Communication:
Stakeholder Management: Maintaining regular communication with stakeholders, providing updates on project progress, and managing expectations.
Team Communication: Facilitating effective communication within the development team to ensure alignment and collaboration.

5.Quality Assurance:
Setting Standards: Establishing quality standards and ensuring that the project meets these standards.
Monitoring Quality: Implementing processes to monitor and maintain the quality of deliverables.

6.Monitoring and Control:
Tracking Progress: Using project management tools to track progress against the schedule and budget.
Making Adjustments: Identifying deviations from the plan and making necessary adjustments to keep the project on track.

7.Documentation:
Maintaining Records: Ensuring that all project documentation is up to date and comprehensive, including project plans, schedules, risk management plans, and status reports.
8.Leadership:
Motivating Team: Inspiring and motivating the team to achieve project goals.
Conflict Resolution: Addressing and resolving conflicts within the team and with stakeholders.

Challenges Faced in Managing Software Projects
1.Scope Creep
Managing stakeholder expectations and maintaining a clear and agreed-upon scope throughout the project lifecycle.

2.Resource Constraints:
Efficiently allocating and managing resources to ensure project progress without overburdening the team.

3.Communication Gaps:
Ensuring clear, consistent, and transparent communication to avoid misunderstandings and misaligned expectations.

4.Changing Requirements:
Managing changes effectively without disrupting the project timeline and maintaining flexibility to adapt to new requirements.

5.Technical Challenges:
Addressing technical challenges promptly and ensuring the team has the necessary skills and knowledge to overcome them.

6.Risk Management:
Proactively managing risks and being prepared to handle unexpected issues that arise.

7.Quality Control:
Balancing quality with time and budget constraints, and implementing effective quality assurance processes.

8.Time Management:
Managing the project schedule effectively to ensure timely delivery, especially when facing unexpected delays or changes.

9.Stakeholder Management:
Balancing conflicting interests and ensuring all stakeholders are satisfied with the project outcomes.

Software Maintenance:
Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?

Answer:
Software mantainance refers to the process of modifying and updating software applications after their initial deployment to correct faults, improve performance, or adapt the software to a changed environment

Types Of Software Mantainance

1.Corrective Maintenance:
Involves fixing bugs or errors discovered after the software has been deployed.
Objective: To correct defects that affect the functionality of the software.
Example: Fixing a security vulnerability or resolving a bug that causes a system crash.

2.Adaptive Maintenance:
Adjusts the software to work in a new or changed environment.
Objective: To ensure the software continues to operate correctly when there are changes in the operating system, hardware, or other external dependencies.
Example: Updating software to be compatible with a new version of an operating system or integrating with new hardware.

3.Perfective Maintenance:
Enhances the performance or maintainability of the software by improving or adding features.
Objective: To improve the software's functionality and performance, making it more efficient and effective for users.
Example: Optimizing code for better performance, adding new features based on user feedback, or improving the user interface.

4.Preventive Maintenance:
Involves making changes to prevent potential future problems.
Objective: To improve the software’s reliability and reduce the likelihood of future issues.
Example: Refactoring code to improve its structure, conducting regular performance tuning, or updating documentation.

Importance of Software Maintenance

1.Longevity and Relevance:
Ensures that the software remains useful and relevant over time, adapting to changing user needs and technological advancements.

2.Cost Efficiency:
Regular maintenance can prevent major issues, which might be costly and time-consuming to fix if left unaddressed.

3.User Satisfaction:
Keeping the software updated and bug-free ensures a better user experience and higher satisfaction.

4.Compliance:
Ensures that the software continues to comply with new regulations and standards.

5.Security:
Regular updates and patches help protect the software from security vulnerabilities and threats.

Ethical Considerations in Software Engineering: 
Ethical considerations in software engineering are critical as the decisions and actions of software engineers can significantly impact individuals, organizations, and society as a whole. Ethical behavior ensures the responsible creation, deployment, and maintenance of software systems.

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?

Answer:

Ethical Issues in Software Engineering
Software engineers might encounter a variety of ethical issues during their careers. These issues can arise from the nature of their work, the contexts in which they operate, and the potential impacts their products can have on individuals and society. Some of the key ethical issues include:

1.Privacy and Data Protection:
Issue: Handling sensitive personal data, ensuring its confidentiality, and protecting it from unauthorized access or breaches.
Example: Developing software that collects user data without adequate security measures or consent.

2.Security:
Issue: Ensuring that software is secure against attacks and vulnerabilities that could be exploited by malicious entities.
Example: Releasing software with known security flaws due to tight deadlines or budget constraints.

3.Intellectual Property:
Issue: Respecting copyrights, patents, and licenses of software and digital content.
Example: Using or distributing pirated software or incorporating proprietary code without proper authorization.

4.Bias and Fairness:
Issue: Ensuring that software systems, especially those involving AI and machine learning, are free from bias and provide fair outcomes for all users.
Example: Developing a hiring algorithm that inadvertently discriminates against certain groups.

5.Transparency and Accountability:
Issue: Being transparent about how software functions, especially in terms of data collection, usage, and decision-making processes.
Example: Creating software that makes decisions affecting users' lives without clear explanations of the criteria used.

6.Accessibility:
Issue: Ensuring that software is usable by people with disabilities, adhering to accessibility standards and guidelines.
Example: Developing a web application that is not navigable by screen readers.

7.Environmental Impact:
Issue: Considering the environmental implications of software development, such as energy consumption and electronic waste.
Example: Developing software that requires excessive computational power, leading to higher energy consumption.

8.Whistleblowing:
Issue: Reporting unethical practices within an organization, even at the risk of personal or professional consequences.
Example: Disclosing that a company is using software to conduct illegal surveillance on users.

9.Conflict of Interest:
Issue: Ensuring that personal interests do not interfere with professional duties and responsibilities.
Example: A software engineer accepting a bribe to modify a system in a way that benefits a third party at the expense of others.

Ensuring Adherence to Ethical Standards
Software engineers can take several steps to ensure they adhere to ethical standards in their work:

1.Education and Awareness:
Stay informed about ethical principles and current issues in the field of software engineering. Engage in continuous learning through professional development, workshops, and ethical training programs.

2.Adherence to Professional Codes of Ethics:
Follow the guidelines set out by professional organizations such as the ACM (Association for Computing Machinery) and IEEE (Institute of Electrical and Electronics Engineers). These codes provide a framework for ethical behavior.

3.Ethical Decision-Making Models:
Utilize ethical decision-making models to systematically analyze and resolve ethical dilemmas. This can involve considering the consequences, duties, rights, and virtues related to a decision.

4.Transparency and Communication:
Maintain open and honest communication with stakeholders, clients, and team members. Ensure that users are informed about how their data is collected, used, and protected.

5.User-Centric Approach:
Prioritize the needs and rights of users when designing and developing software. This includes implementing robust data protection measures, ensuring accessibility, and designing for inclusivity.

6.Quality Assurance and Testing:
Implement rigorous testing and quality assurance processes to identify and mitigate potential issues. This includes security testing, bias testing, and accessibility testing.

7.Ethical Leadership:
Lead by example and foster an ethical culture within the organization. Encourage team members to voice ethical concerns and support them in making ethical decisions.

8.Documentation and Accountability:
Maintain thorough documentation of decisions, processes, and changes. This provides accountability and traceability, ensuring that decisions can be reviewed and justified.

9.Engage with Ethical Review Boards:
Participate in or consult with ethical review boards or committees when dealing with complex ethical issues. These boards can provide guidance and oversight.

10.Legal and Regulatory Compliance:
Ensure that all software development practices comply with relevant laws and regulations. This includes data protection laws, accessibility standards, and intellectual property rights.

Therefore by adhering to these practices, software engineers can navigate ethical challenges effectively and contribute to the creation of software that is not only functional and innovative but also responsible and beneficial to society.


References

1.ACM Code of Ethics and Professional Conduct:
Association for Computing Machinery. (2018). ACM Code of Ethics and Professional Conduct. Retrieved from ACM

2.IEEE Code of Ethics:
Institute of Electrical and Electronics Engineers. (2020). IEEE Code of Ethics. Retrieved from IEEE

3.Software Maintenance:
Sommerville, I. (2011). Software Engineering (9th ed.). Addison-Wesley.
Pressman, R. S. (2014). Software Engineering: A Practitioner's Approach (8th ed.). McGraw-Hill.

4.Ethics in Software Engineering:
Martin, C. D., & Schinzinger, R. (2005). Ethics in Engineering (4th ed.). McGraw-Hill.
Reynolds, G. W. (2018). Ethics in Information Technology (6th ed.). Cengage Learning.

5.Version Control Systems:
Chacon, S., & Straub, B. (2014). Pro Git (2nd ed.). Apress. Available at Pro Git Book

6.Software Project Management:
Hughes, B., & Cotterell, M. (2009). Software Project Management (5th ed.). McGraw-Hill.
Project Management Institute. (2017). A Guide to the Project Management Body of Knowledge (PMBOK® Guide) (6th ed.). Project Management Institute.
